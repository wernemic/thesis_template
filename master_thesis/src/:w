%!TEX root = ../main.tex

\chapter{Methods}



\section{Source localisation}

\section{MLEM}

\section{Search strategy}
The maximum likelihood approach requires collecting as many measurements as possible to make the estimate more accurate.
At the same time, the drones should explore the unexplored area to increase chance that the estimation method won't miss any source of ionizing radiation.
The task for the mutirobotic system can be summarized as follows:
\begin{itemize}
  \item \textbf{exploration} - explore the least explored maps in the area of interest
  \item \textbf{exploitation} - acquire more measurements from areas, where the source of ionizing radiation is likely present
\end{itemize}
 
This general strategy is divided into subtasks: waypoint generation, task assignment and path planning.
\subsection{Waypoint generation}
s a first step, the $\lambda$ matrix (containing the current estimate of sources position) is processed by a local maximum filter. 
The maximum filter works by sliding a window of a specified size over the $\lambda$.
The central position of the sliding window is highlighted as local maxima if it is greater than all other values in the sliding window.

Each waypoint (local maxima) is assigned with a weight $w$.
The weight is defined as follows:
\begin{equation}
  w_{j} = \frac{\lambda_{j}}{s_{j_{normalised}}}
\end{equation},
where $s_{j_{normalised}} = \frac{s_{j}}{\max_{J}( s_{j})}$ is a sensitivity value for given position $s_{j}$ divided by.
Such formulation of $w_{j}$ prioritise the points with the highest current estimate of ionizing radiation, that are less explored (have lower sensitivity).

\subsection{Task assignment}

To fasten the search time, the waypoints are divided among all the \ac{UAV}s involved in the experiment.
This is done by KMeans clustering method with minimum number of samples within each cluster.

The KMeans algorithm is an iterative clustering algorithm, that can divide data points into $k$ clusters.
Each cluster is represented with a virtual point called centroid, $c_{k}, k = 1, ... , K$, where $K$ is the number of clusters.
The algorithm proceeds as follows:

\begin{lstlisting}[caption={DroneDataMsg.msg (caption)}, title={Custom message for data sharing between \ac{UAV} and central unit.}, label={code1}]
Header header
geometry_msgs/Pose pose
geometry_msgs/Pose sensor_pose
geometry_msgs/PointStamped predicted_point
std_msgs/String status
\end{lstlisting}


\subsection{Travelling salesman problem}
This is a classical problem in computer science.
The problem is formulated as follows:
A complete oriented graph is given, where $V$ (set of vertices) represent locations that should be visited and $E$ (set of edges) represents the distances between then vertices.
The task is to find the path through the vertices (more precisely: Hamiltonian cycle), so that each vertex is visited exactly once, the starting and ending point are the same and the distance of the path is minimal (the sum of weights assigned to the edges involved in the path is minimal possible).
The edges of the graph are typically stored in the so called distance matrix $\mathbf{D}\in \mathbb{R}^{\left|V\right|\times\left|V\right|}$, where $d_{ab}$ represents distance from vertex $a$ to vertex $b$.

The problem of finding optimal sequence of points of interest $\{1, 2, \dots , n\}$ for an \ac{UAV} is transformed to the travelling salesman problem and solved using LKH solver\footnote{available at: http://webhotel4.ruc.dk/~keld/research/LKH/}.
However, we require some aditional features.
The starting vertex of the optimal sequence should be the future position of the drone, we denote it as vertex $0$.
Secondly, we don't require to finish the route in the staring point.
Because of that, we introduce dummy vertex denoted as $F$.

We formulate the transformed problem as follows:
The set of vertices is $\{0, 1, 2, \dots,n,  F\} \in V$, where $0$ is the starting point of the optimal sequence of points, $1, 2, \dots, n$ are the points to be visited by the \ac{UAV} and $F$ is the dummy vertex.
The distance matrix $\mathbf{D}$ is formulated as

\begin{equation}
  \mathbf{D_{mod}} = 
  \begin{pmatrix}
    0 & d_{0,1} & d_{0,2} & \dots & d_{0, n} & d_{0, F} \\
    d_{1,0} & 0 & d_{1,2} & \dots & d_{0, n} & d_{0, F} \\
    0 & d_{0,1} & d_{2,2} & \dots & d_{0, n} & d_{0, F} \\
    0 & d_{0,1} & d_{3,2} & \dots & d_{0, n} & d_{0, F} \\
    d_{n,0} & d_{n, 1} & d_{n, 2} & d_{n, 3} & d_{n, n} & d_{n, F} \\
    0 & d_{0,1} & d_{0,2} & \dots & d_{0, n} & d_{0, F} 
\end{pmatrix}
\end{equation}

\begin{equation}
  \mathbf{D_{mod}} = 
  \begin{pmatrix}
    0 & d_{0,1} & d_{0,2}     & \dots & M \\
    M & 0 & d_{1,2} & \dots & 0\\
    M & d_{2,1} & 0 & \dots & 0\\
    \dots & \dots & \dots & \dots & \dots \\
    0 & M & M & \dots & 0,
\end{pmatrix}
\end{equation}
where $d_{a,b}$ is the euklidean distance from vertex $a$ to vertex $b$, $M$ is a positive constant, $M>d \forall d \in D$.
The picture \ref{} shows the task for 3 waypoints to be visited.
The starting point (future position of the \ac{UAV}) is represented with vertex $0$.
This point is required to be the first one.
Aditionally, the dummy vertex $F$ is introduced.


Unlike in \textbf{TSP} problem, we do not require starting and finishing at the same position.
Because of tha



\subsection{Path planning}


\begin{algorithm}
\caption{Multi-path planning}\label{alg:cap}
\begin{algorithmic}

\Function {plan\_paths}{$drones\_waypoints, drones\_poses$}
  \State $planned\_paths \gets \{\}$
  \For {$drone \in drones$} \Comment{iterate over drones based on priority}
    \State $obstacles \gets \{\}$
    \For {$path \in planned\_paths$}
      \State $obstacles \gets obstacles \cup \Call{inflate\_points}{path}$ %\Comment{mark positions around already planned paths as obstacles}
    \EndFor
    \State $path \gets \{\}$
    \State $segment\_start \gets drone\_pose$
    \For {$waypoint \in drone\_waypoints$}

      \If{ $waypoint \in obstacles$}
        \State \textbf{continue}
      \EndIf
      \State $path\_segment \gets \Call{astar\_planner}{start, waypoint, obstacles}$
      \State $segment\_start \gets waypoint$
      \State $path \gets path \cup path\_segment$
    \EndFor
    \State $planned\_paths \gets planned\_paths \cup path$
  \EndFor
  \State \Return $planned\_paths$
\EndFunction


\end{algorithmic}
\end{algorithm}


\section{Pipeline}

\begin{algorithm}
\caption{Planning pipeline}\label{alg:cap}
\begin{algorithmic}
  \State $POI \gets \Call{get\_points\_of\_interest}$
  \State $POI_{sorted} \gets \Call{filter\_points}{POI}$
  \State $POI_{exploration} \gets \Call{get\_unexplored\_area\_points}$
  
  \State $future\_poses \gets \Call{get\_future\_drone\_poses}$

  \State $W_{exploitation} \gets \Call{clustering}{future\_poses}$
  \State $W_{exploration} \gets \Call{clustering}{future\_poses}$
  
  \State
\end{algorithmic}
\end{algorithm}


collect more measurements
explore the least explored area

\subsection{Multirobotic approach}
there are two approaches - centralised and decentralised.
I use centralised.


